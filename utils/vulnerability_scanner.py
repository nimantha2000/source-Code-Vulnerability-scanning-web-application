import re
import os
import subprocess
from werkzeug.utils import secure_filename

def scan_code_for_vulnerabilities(file):
    vulnerabilities = {
        'SQL Injection': [],
        'XSS': [],
        'Buffer Overflow': [],
        'Eval Injection': [],
        'Payload Injection': [],
        'Insecure Design': [],
        'Vulnerable Components': [],
        'Insecure Cryptographic Storage': [],
        'LDAP Injection': [],
        'Security Misconfigurations': []  # Added Security Misconfigurations vulnerability type
    }

    try:
        # Create a temporary directory if it doesn't exist
        temp_dir = 'temp_files'
        os.makedirs(temp_dir, exist_ok=True)

        # Save the uploaded file to a temporary location
        filename = secure_filename(file.filename)
        file_path = os.path.join(temp_dir, filename)
        file.save(file_path)

        # Regular expressions/patterns to identify potential vulnerabilities or insecure design patterns
        sql_injection_pattern = re.compile(r'.*(select|insert|update|delete|alter|drop|create|truncate).*'
                                           r'(from|into|table|database|where|values).*', re.IGNORECASE)
        xss_pattern = re.compile(r'(\b|[^-]_)((document|window|eval|alert|prompt|confirm)'
                                 r'(\s*\(.*\)))', re.IGNORECASE)
        buffer_overflow_pattern = re.compile(r'\bstrcpy\s*\(\s*[^\s,]+\s*,.*\);?', re.IGNORECASE)
        eval_injection_pattern = re.compile(r'\beval\s*\(\s*.*\s*\);?', re.IGNORECASE)
        payload_injection_pattern = re.compile(r'(\b|[^-]_)((os|exec|system)\s*\(\s*".*"\s*\))', re.IGNORECASE)
        insecure_design_pattern = re.compile(r'(username|password)', re.IGNORECASE)
        ldap_injection_pattern = re.compile(r'\*|\(|\)|&(?!amp;)', re.IGNORECASE)
        security_misconfig_pattern = re.compile(r'(default\s*configuration|open\s*storage|misconfigured\s*header)', re.IGNORECASE)  # Pattern for Security Misconfigurations
        insecure_crypto_pattern = re.compile(r'(md5|sha1)', re.IGNORECASE)  # Pattern for insecure cryptographic storage

        safety_check_command = f"safety check --file {file_path}"
        safety_check_output = subprocess.run(safety_check_command, shell=True, capture_output=True, text=True)

        if safety_check_output.returncode == 0:
            # Safety check successful, process the vulnerabilities found
            output_lines = safety_check_output.stdout.splitlines()
            for line in output_lines:
                if "Vulnerability" in line:
                    # Extract vulnerable component details and add to vulnerabilities list
                    vulnerabilities['Vulnerable Components'].append({
                        'vulnerability_type': 'Vulnerable Component',
                        'vulnerable_component': line.strip()
                    })
        else:
            print("Safety check failed:", safety_check_output.stderr)
        
        # Open the file and scan for vulnerabilities including Security Misconfigurations
        with open(file_path, 'r') as file_content:
            lines = file_content.readlines()
            line_number = 0

            for line in lines:
                line_number += 1
                if sql_injection_pattern.search(line):
                    vulnerabilities['SQL Injection'].append({
                        'vulnerability_type': 'Potential SQL Injection',
                        'line_number': line_number,
                        'code_snippet': line.strip()
                    })
                if xss_pattern.search(line):
                    vulnerabilities['XSS'].append({
                        'vulnerability_type': 'Potential XSS',
                        'line_number': line_number,
                        'code_snippet': line.strip()
                    })
                if buffer_overflow_pattern.search(line):
                    vulnerabilities['Buffer Overflow'].append({
                        'vulnerability_type': 'Potential Buffer Overflow',
                        'line_number': line_number,
                        'code_snippet': line.strip()
                    })
                if eval_injection_pattern.search(line):
                    vulnerabilities['Eval Injection'].append({
                        'vulnerability_type': 'Potential Eval Injection',
                        'line_number': line_number,
                        'code_snippet': line.strip()
                    })
                if payload_injection_pattern.search(line):
                    vulnerabilities['Payload Injection'].append({
                        'vulnerability_type': 'Potential Payload Injection',
                        'line_number': line_number,
                        'code_snippet': line.strip()
                    })
                if insecure_design_pattern.search(line):
                    vulnerabilities['Insecure Design'].append({
                        'vulnerability_type': 'Potential Insecure Design',
                        'line_number': line_number,
                        'code_snippet': line.strip()
                    })
                if ldap_injection_pattern.search(line):
                    vulnerabilities['LDAP Injection'].append({
                        'vulnerability_type': 'Potential LDAP Injection',
                        'line_number': line_number,
                        'code_snippet': line.strip()
                    })
                if security_misconfig_pattern.search(line):
                    vulnerabilities['Security Misconfigurations'].append({
                        'vulnerability_type': 'Potential Security Misconfiguration',
                        'line_number': line_number,
                        'code_snippet': line.strip()
                    })
                if insecure_crypto_pattern.search(line):
                    vulnerabilities['Insecure Cryptographic Storage'].append({
                        'vulnerability_type': 'Insecure Cryptographic Storage',
                        'line_number': line_number,
                        'code_snippet': line.strip()
                    })

    except FileNotFoundError:
        print(f"File not found: {file_path}")
        # You can handle this exception as per your application's needs

    return vulnerabilities
