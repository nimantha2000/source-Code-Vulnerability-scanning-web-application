/ Buffer Overflow vulnerability
#include <string.h>

void vulnerable_function(char *input) {
    char buffer[10];
    strcpy(buffer, input); // Vulnerable code: No bounds checking on the input size
}

# Cross-Site Scripting (XSS) vulnerability
def render_input(input_data):
    # Vulnerable code: Rendering user input directly into HTML without proper encoding
    html_output = "<p>" + input_data + "</p>"
    return html_output

    # SQL Injection vulnerability
import sqlite3

def vulnerable_sql_query(user_input):
    conn = sqlite3.connect('example.db')
    cursor = conn.cursor()

    # Vulnerable code: Concatenating user input directly into the SQL query
    cursor.execute("SELECT * FROM users WHERE username = '" + user_input + "'")

    rows = cursor.fetchall()
    for row in rows:
        print(row)

    conn.close()

# Vulnerable code susceptible to Eval Injection
def evaluate_input(expression):
    # Vulnerable code: Using 'eval()' to evaluate the input expression
    result = eval(expression)
    return result

# Usage example
user_input = input("Enter an expression to evaluate: ")
result = evaluate_input(user_input)
print("Result:", result)


import os

def execute_command(command):
    # Vulnerable code: Using 'os.system()' with unsanitized user input
    os.system("echo " + command)
    # In a real scenario, this could execute arbitrary commands provided by the user

# Usage example
user_input = input("Enter a command to execute: ")
execute_command(user_input)

# Example code with potential Insecure Design

# Hardcoded credentials (insecure practice)
username = "admin"
password = "password123"

def login(user, pwd):
    # Insecure comparison of credentials
    if user == username and pwd == password:
        return True
    else:
        return False

# Usage example
input_username = input("Enter username: ")
input_password = input("Enter password: ")

if login(input_username, input_password):
    print("Login successful")
else:
    print("Login failed")

    # Example test file demonstrating multiple vulnerabilities

# SQL Injection Vulnerability
def vulnerable_sql_query(user_input):
    # Vulnerable code: Concatenating user input directly into the SQL query
    query = "SELECT * FROM users WHERE username = '" + user_input + "'"
    # In a real scenario, this could lead to SQL Injection

# Cross-Site Scripting (XSS) Vulnerability
def render_input(input_data):
    # Vulnerable code: Rendering user input directly into HTML without proper encoding
    html_output = "<p>" + input_data + "</p>"
    # In a real scenario, this could lead to XSS vulnerability

# Buffer Overflow Vulnerability (C Code snippet)
#include <string.h>

void vulnerable_function(char *input) {
    char buffer[10];
    strcpy(buffer, input); // Vulnerable code: No bounds checking on the input size
}

# Eval Injection Vulnerability
def execute_expression(expression):
    # Vulnerable code: Using 'eval()' with unsanitized user input
    result = eval(expression)
    # In a real scenario, this could lead to Eval Injection

# Payload Injection Vulnerability
import subprocess

def execute_command(command):
    # Vulnerable code: Using 'subprocess.run()' with unsanitized user input
    subprocess.run(["echo", command])
    # In a real scenario, this could lead to Payload Injection

# Insecure Design (Hardcoded Credentials)
username = "admin"
password = "password123"

def login(user, pwd):
    # Insecure comparison of credentials
    if user == username and pwd == password:
        return True
    else:
        return False


import hashlib

# Insecure cryptographic storage using MD5
def insecure_crypto_md5(password):
    # Vulnerable code: Using MD5 for hashing passwords (insecure)
    hashed_password = hashlib.md5(password.encode()).hexdigest()
    return hashed_password

# Insecure cryptographic storage using SHA1
def insecure_crypto_sha1(password):
    # Vulnerable code: Using SHA1 for hashing passwords (insecure)
    hashed_password = hashlib.sha1(password.encode()).hexdigest()
    return hashed_password
